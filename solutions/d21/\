#!/usr/bin/env python3
from pathlib import Path
import argparse
import logging
import sys
from time import time

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler(sys.stdout))

NUMPAD = {
        0:'7',1:'8',2:'9',
        1j:'4',1+1j:'5',2+1j:'6',
        2j:'1',1+2j:'2',2+2j:'3',
        1+3j:'0',2+3j:'A'
        }
NUMPOS = {v:k for k, v in NUMPAD.items()}
DPAD = {
        1:'^',2:'A',
        1j:'<',1+1j:'v',2+1j:'>'
        }
DPOS = {v:k for k, v in DPAD.items()}
def read_line(fpath: str):
    """Reads the input and yields each line"""
    fpath = Path(fpath)
    with open(fpath) as f:
        yield from f

def dist_to_buttons(dist: complex) -> str:
    """
    given a complex representing the manhattan dist
    return direction in terms of arrows
    e.g. 1+2j -> '>vv'
    """
    buttons = ''
    if (x := int(dist.real)) > 0:
        buttons += '>' * x
    else:
        buttons += '<' * abs(x)

    if (y := int(dist.imag)) > 0:
        buttons += 'v' * y
    else:
        buttons += '^' * abs(y)
    #logger.debug(f'buttons: {buttons}')
    return buttons

def press_numpad(code: str) -> list:
    """
    return movement and presses required for the code
    """
    pos = NUMPOS['A']
    buttons = ''
    #logger.debug(f'processing code {code}')
    for key in code:
        dist = NUMPOS[key] - pos
        #logger.debug(f'{NUMPAD[pos],key}: {dist}')
        buttons += dist_to_buttons(dist)
        buttons += 'A'
        pos = NUMPOS[key]
    return buttons
    
def press_dpad(cmds: str) -> list:
    """
    return movement and presses required for dpad
    """
    pos = DPOS['A']
    buttons = ''
    for press in cmds:
        dist = DPOS[press] - pos
        #logger.debug(f'{DPAD[pos],press}: {dist}')
        buttons += dist_to_buttons(dist)
        buttons += 'A'
        pos = DPOS[press]
    return buttons

    
def main(sample: bool, part_two: bool, loglevel: str):
    """ """
    logger.setLevel(loglevel)
    if not sample:
        fp = "input.txt"
    else:
        fp = "sample.txt"
    logger.debug(f"loglevel: {loglevel}")
    logger.info(f'Using {fp} for {"part 2" if part_two else "part 1"}')

    # read input
    codes = [line.strip() for line in read_line(fp)]

    # execute
    cmplx = 0
    for code in codes:
        num = int(code[:3])
        buttons = press_numpad(code)
        b1 = press_dpad(buttons)
        b2 = press_dpad(b1)
        #b3 = press_dpad(b2)
        cmplx += len(b2) * num
        logger.debug(f'numpad movements {buttons}')
        logger.debug(f'num: {num}')
        logger.debug(f'dpad movements {len(b2), b2}')
    # output
    ans = cmplx
    return ans

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    opt = parser.add_argument
    opt("--sample", "-s", action="store_true", default=False)
    opt("--part_two", "-t", action="store_true", default=False)
    opt("--loglevel", "-l", type=str.upper, default="info")
    args = parser.parse_args()
    tstart = time()
    ans = main(args.sample, args.part_two, args.loglevel)
    tstop = time()
    logger.info(f"runtime: {(tstop-tstart)*1e3:.3f} ms")
    print('ans ', ans)
